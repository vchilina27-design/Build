<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="true">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Tank Battle 3D">
    <meta name="description" content="A 3D tank battle game optimized for mobile devices">
    <meta name="theme-color" content="#1a1a1a">
    <title>Tank Battle 3D - Mobile Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Arial', sans-serif;
            position: fixed;
        }

        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: linear-gradient(to bottom, #2a4a6f, #1a1a1a);
        }

        canvas#gameCanvas {
            flex: 1;
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
            justify-content: space-between;
            align-items: center;
            z-index: 101;
            pointer-events: all;
        }

        .joystick {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            position: relative;
            touch-action: none;
        }

        .joystick-thumb {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: background 0.1s;
        }

        .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .game-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(220, 20, 60, 0.8);
            border: 2px solid rgba(220, 20, 60, 1);
            color: white;
            font-weight: bold;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            touch-action: none;
            user-select: none;
        }

        .game-button:active {
            transform: scale(0.95);
            background: rgba(220, 20, 60, 1);
        }

        #stats {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 10px #00ff00;
            z-index: 101;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 5px;
            min-width: 200px;
        }

        .stat-line {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        #healthBar {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0000;
            border-radius: 5px;
            z-index: 101;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            width: 100%;
            transition: width 0.2s;
        }

        #ammoIndicator {
            position: fixed;
            bottom: 120px;
            right: 20px;
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-shadow: 0 0 10px #ffff00;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 101;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            gap: 20px;
        }

        #menu.hidden {
            display: none;
        }

        .menu-title {
            font-size: 48px;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            margin-bottom: 30px;
            font-weight: bold;
        }

        .menu-button {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(to right, #ff6b00, #ff8c00);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
            width: 250px;
            text-align: center;
        }

        .menu-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.8);
        }

        .menu-button:active {
            transform: scale(0.95);
        }

        @media (max-width: 600px) {
            #stats {
                font-size: 12px;
                top: 10px;
                left: 10px;
                padding: 10px;
            }

            #healthBar {
                width: 150px;
                height: 25px;
                top: 10px;
                right: 10px;
            }

            #controls {
                bottom: 10px;
                left: 10px;
                right: 10px;
                gap: 10px;
            }

            .joystick {
                width: 80px;
                height: 80px;
            }

            .game-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="hud">
        <div id="stats">
            <div class="stat-line">
                <span>FPS:</span>
                <span id="fps">60</span>
            </div>
            <div class="stat-line">
                <span>Enemies:</span>
                <span id="enemyCount">0</span>
            </div>
            <div class="stat-line">
                <span>Score:</span>
                <span id="score">0</span>
            </div>
        </div>

        <div id="healthBar">
            <div class="health-fill" id="healthFill"></div>
        </div>

        <div id="ammoIndicator">
            <span id="ammoCount">100</span> / 100
        </div>

        <div id="controls">
            <div class="joystick" id="movementJoystick">
                <div class="joystick-thumb"></div>
            </div>
            <div class="button-group">
                <button class="game-button" id="fireButton">ðŸ”«</button>
                <button class="game-button" id="abilityButton">âš¡</button>
            </div>
        </div>
    </div>

    <div id="menu">
        <div class="menu-title">TANK BATTLE 3D</div>
        <button class="menu-button" id="playButton">PLAY</button>
        <button class="menu-button" id="settingsButton">SETTINGS</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const CONFIG = {
            VIEWPORT_WIDTH: window.innerWidth,
            VIEWPORT_HEIGHT: window.innerHeight,
            FOV: 75,
            CAMERA_DISTANCE: 20,
            PLAYER_SPEED: 0.3,
            PLAYER_ROTATION_SPEED: 0.05,
            TANK_SIZE: 2,
            ENEMY_COUNT: 5,
            ENEMY_SPEED: 0.1,
            PROJECTILE_SPEED: 1,
            ENEMY_FIRE_RATE: 2000, // ms
            MAX_HEALTH: 100,
            MAX_AMMO: 100
        };

        // Game State
        let gameState = {
            isRunning: false,
            health: CONFIG.MAX_HEALTH,
            ammo: CONFIG.MAX_AMMO,
            score: 0,
            fps: 0,
            frameCount: 0,
            lastTime: Date.now()
        };

        // Three.js Scene Setup
        let scene, camera, renderer, playerTank, enemies = [], projectiles = [];

        function initScene() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a4a6f);
            scene.fog = new THREE.Fog(0x2a4a6f, 100, 200);

            // Camera
            camera = new THREE.PerspectiveCamera(CONFIG.FOV, CONFIG.VIEWPORT_WIDTH / CONFIG.VIEWPORT_HEIGHT, 0.1, 1000);
            camera.position.set(0, CONFIG.CAMERA_DISTANCE, CONFIG.CAMERA_DISTANCE);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('gameCanvas') });
            renderer.setSize(CONFIG.VIEWPORT_WIDTH, CONFIG.VIEWPORT_HEIGHT);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c3b });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create Player Tank
            playerTank = createTank(0, 0, 0, 0x0055ff);
            scene.add(playerTank);

            // Create Enemies
            for (let i = 0; i < CONFIG.ENEMY_COUNT; i++) {
                const angle = (i / CONFIG.ENEMY_COUNT) * Math.PI * 2;
                const distance = 40;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                const enemy = createTank(x, 0, z, 0xff3333);
                enemy.isEnemy = true;
                enemy.lastFireTime = 0;
                enemy.targetAngle = 0;
                enemies.push(enemy);
                scene.add(enemy);
            }
        }

        function createTank(x, y, z, color) {
            const tank = new THREE.Group();
            tank.position.set(x, y, z);
            tank.rotation.y = 0;
            tank.velocity = new THREE.Vector3(0, 0, 0);

            // Tank body
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            tank.add(body);

            // Tank turret
            const turret = new THREE.Group();
            turret.position.y = 0.6;
            tank.add(turret);

            const turretGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.6, 32);
            const turretMesh = new THREE.Mesh(turretGeometry, bodyMaterial);
            turretMesh.castShadow = true;
            turretMesh.receiveShadow = true;
            turret.add(turretMesh);

            // Tank barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 16);
            const barrelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.z = 1.2;
            barrel.rotation.x = Math.PI / 2;
            barrel.castShadow = true;
            barrel.receiveShadow = true;
            turret.add(barrel);
            tank.turret = turret;
            tank.barrel = barrel;

            // Wheels
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
                    const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(i * 0.7, 0.3, j * 1);
                    wheel.castShadow = true;
                    wheel.receiveShadow = true;
                    body.add(wheel);
                }
            }

            return tank;
        }

        function update() {
            if (!gameState.isRunning) return;

            // Update player tank
            updatePlayerTank();

            // Update enemies
            enemies.forEach(enemy => updateEnemy(enemy));

            // Update projectiles
            updateProjectiles();

            // Update HUD
            updateHUD();

            // Clamp player position
            playerTank.position.x = Math.max(-95, Math.min(95, playerTank.position.x));
            playerTank.position.z = Math.max(-95, Math.min(95, playerTank.position.z));

            // Update camera to follow player
            const cameraOffset = 15;
            camera.position.x = playerTank.position.x;
            camera.position.z = playerTank.position.z + cameraOffset;
            camera.lookAt(playerTank.position.x, 5, playerTank.position.z);
        }

        function updatePlayerTank() {
            // Movement controlled by joystick (implemented in event listeners)
            playerTank.position.add(playerTank.velocity);
            playerTank.velocity.multiplyScalar(0.9); // Friction
        }

        function updateEnemy(enemy) {
            const direction = new THREE.Vector3().subVectors(playerTank.position, enemy.position);
            direction.y = 0;
            direction.normalize();

            // Move towards player
            enemy.position.addScaledVector(direction, CONFIG.ENEMY_SPEED);

            // Rotate to face player
            const targetAngle = Math.atan2(direction.x, direction.z);
            enemy.rotation.y += (targetAngle - enemy.rotation.y) * 0.05;

            // Fire at player occasionally
            const currentTime = Date.now();
            if (currentTime - enemy.lastFireTime > CONFIG.ENEMY_FIRE_RATE) {
                fireProjectile(enemy, false);
                enemy.lastFireTime = currentTime;
            }

            // Keep enemy in bounds
            enemy.position.x = Math.max(-95, Math.min(95, enemy.position.x));
            enemy.position.z = Math.max(-95, Math.min(95, enemy.position.z));
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                projectile.position.addScaledVector(projectile.velocity, CONFIG.PROJECTILE_SPEED);

                // Check bounds
                if (Math.abs(projectile.position.x) > 100 || Math.abs(projectile.position.z) > 100) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                    continue;
                }

                // Collision detection with player
                if (!projectile.isPlayerProjectile) {
                    const distance = projectile.position.distanceTo(playerTank.position);
                    if (distance < 3) {
                        gameState.health -= 10;
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        continue;
                    }
                }

                // Collision detection with enemies
                if (projectile.isPlayerProjectile) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const distance = projectile.position.distanceTo(enemies[j].position);
                        if (distance < 3) {
                            scene.remove(enemies[j]);
                            enemies.splice(j, 1);
                            scene.remove(projectile);
                            projectiles.splice(i, 1);
                            gameState.score += 100;
                            break;
                        }
                    }
                }
            }
        }

        function fireProjectile(tank, isPlayer) {
            if (isPlayer && gameState.ammo <= 0) return;
            if (isPlayer) gameState.ammo--;

            const geometry = new THREE.SphereGeometry(0.2, 8, 8);
            const material = new THREE.MeshPhongMaterial({ color: isPlayer ? 0xffff00 : 0xff6600 });
            const projectile = new THREE.Mesh(geometry, material);

            const barrelWorldPos = new THREE.Vector3();
            tank.barrel.getWorldPosition(barrelWorldPos);
            projectile.position.copy(barrelWorldPos);

            const direction = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(1, 0, 0), tank.turret.rotation.x);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), tank.rotation.y);
            projectile.velocity = direction;

            projectile.isPlayerProjectile = isPlayer;
            scene.add(projectile);
            projectiles.push(projectile);
        }

        function updateHUD() {
            const currentTime = Date.now();
            gameState.frameCount++;

            if (currentTime - gameState.lastTime >= 1000) {
                gameState.fps = gameState.frameCount;
                gameState.frameCount = 0;
                gameState.lastTime = currentTime;
            }

            document.getElementById('fps').textContent = gameState.fps;
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('ammoCount').textContent = gameState.ammo;
            document.getElementById('healthFill').style.width = (gameState.health / CONFIG.MAX_HEALTH * 100) + '%';

            if (gameState.health <= 0) {
                gameState.isRunning = false;
                showGameOver();
            }
        }

        // Input Handling
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') fireProjectile(playerTank, true);
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Joystick handling for mobile
        const movementJoystick = document.getElementById('movementJoystick');
        const joystickThumb = movementJoystick.querySelector('.joystick-thumb');
        let joystickActive = false;

        movementJoystick.addEventListener('touchstart', (e) => {
            joystickActive = true;
        });

        movementJoystick.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;
            e.preventDefault();

            const rect = movementJoystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const touch = e.touches[0];
            const deltaX = touch.clientX - centerX;
            const deltaY = touch.clientY - centerY;

            const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 50);
            const angle = Math.atan2(deltaY, deltaX);

            joystickThumb.style.left = (50 + Math.cos(angle) * distance / 50 * 30) + '%';
            joystickThumb.style.top = (50 + Math.sin(angle) * distance / 50 * 30) + '%';

            if (gameState.isRunning) {
                const moveForce = CONFIG.PLAYER_SPEED * (distance / 50);
                playerTank.velocity.x += Math.cos(angle + playerTank.rotation.y) * moveForce;
                playerTank.velocity.z += Math.sin(angle + playerTank.rotation.y) * moveForce;
                playerTank.rotation.y = angle;
            }
        });

        movementJoystick.addEventListener('touchend', () => {
            joystickActive = false;
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
        });

        // Fire button
        document.getElementById('fireButton').addEventListener('touchstart', () => {
            if (gameState.isRunning) fireProjectile(playerTank, true);
        });

        document.getElementById('fireButton').addEventListener('mousedown', () => {
            if (gameState.isRunning) fireProjectile(playerTank, true);
        });

        // Menu handlers
        document.getElementById('playButton').addEventListener('click', startGame);
        document.getElementById('settingsButton').addEventListener('click', () => {
            alert('Settings coming soon!');
        });

        function startGame() {
            document.getElementById('menu').classList.add('hidden');
            gameState.isRunning = true;
            gameState.health = CONFIG.MAX_HEALTH;
            gameState.ammo = CONFIG.MAX_AMMO;
            gameState.score = 0;
            
            // Clear previous enemies
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];
            
            // Recreate enemies
            for (let i = 0; i < CONFIG.ENEMY_COUNT; i++) {
                const angle = (i / CONFIG.ENEMY_COUNT) * Math.PI * 2;
                const distance = 40;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                const enemy = createTank(x, 0, z, 0xff3333);
                enemy.isEnemy = true;
                enemy.lastFireTime = 0;
                enemies.push(enemy);
                scene.add(enemy);
            }
        }

        function showGameOver() {
            const menu = document.getElementById('menu');
            menu.classList.remove('hidden');
            menu.innerHTML = `
                <div class="menu-title">GAME OVER</div>
                <div style="color: #ffff00; font-size: 32px; margin: 20px;">Score: ${gameState.score}</div>
                <button class="menu-button" onclick="location.reload()">PLAY AGAIN</button>
            `;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            CONFIG.VIEWPORT_WIDTH = window.innerWidth;
            CONFIG.VIEWPORT_HEIGHT = window.innerHeight;
            camera.aspect = CONFIG.VIEWPORT_WIDTH / CONFIG.VIEWPORT_HEIGHT;
            camera.updateProjectionMatrix();
            renderer.setSize(CONFIG.VIEWPORT_WIDTH, CONFIG.VIEWPORT_HEIGHT);
        });

        // Prevent context menu on long touch
        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Initialize and start game loop
        window.addEventListener('load', () => {
            initScene();
            
            function gameLoop() {
                requestAnimationFrame(gameLoop);
                update();
                renderer.render(scene, camera);
            }
            
            gameLoop();
        });

        // Prevent scrolling on mobile
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>